#!/usr/bin/env python3
from z3 import *

# We create 25 integer variables (each representing one character, in ASCII)
flag = [z3.BitVec(f"flag_{i}", 8) for i in range(25)]
s = Solver()

# Constrain each flag character to be in the printable ASCII range.
for ch in flag:
    s.add(ch >= 32, ch <= 126)

# According to the C code the flag is used to fill a 5x5 matrix.
# The jumbled assignment in genMatrix yields this mapping:
#   mat[0][0] = flag[0]
#   mat[0][1] = flag[16]
#   mat[0][2] = flag[7]
#   mat[0][3] = flag[23]
#   mat[0][4] = flag[14]
#
#   mat[1][0] = flag[5]
#   mat[1][1] = flag[21]
#   mat[1][2] = flag[12]
#   mat[1][3] = flag[3]
#   mat[1][4] = flag[19]
#
#   mat[2][0] = flag[10]
#   mat[2][1] = flag[1]
#   mat[2][2] = flag[17]
#   mat[2][3] = flag[8]
#   mat[2][4] = flag[24]
#
#   mat[3][0] = flag[15]
#   mat[3][1] = flag[6]
#   mat[3][2] = flag[22]
#   mat[3][3] = flag[13]
#   mat[3][4] = flag[4]
#
#   mat[4][0] = flag[20]
#   mat[4][1] = flag[11]
#   mat[4][2] = flag[2]
#   mat[4][3] = flag[18]
#   mat[4][4] = flag[9]
#
# Then the auth string is computed as:
#   auth[0]  = mat[0][0] + mat[4][4] = flag[0]  + flag[9]   == 0x8b (139)
#   auth[1]  = mat[2][1] + mat[0][2] = flag[1]  + flag[7]   == 0xce (206)
#   auth[2]  = mat[4][2] + mat[4][1] = flag[2]  + flag[11]  == 0xb0 (176)
#   auth[3]  = mat[1][3] + mat[3][1] = flag[3]  + flag[6]   == 0x89 (137)
#   auth[4]  = mat[3][4] + mat[1][2] = flag[4]  + flag[12]  == 0x7b (123)
#   auth[5]  = mat[1][0] + mat[2][3] = flag[5]  + flag[8]   == 0xb0 (176)
#   auth[6]  = mat[2][4] + mat[2][0] = flag[24] + flag[10]  == 0xb0 (176)
#   auth[7]  = mat[3][3] + mat[3][2] + mat[0][3] = flag[13] + flag[22] + flag[23] == 0xee (238)
#   auth[8]  = mat[0][4] + mat[4][0] + mat[0][1] = flag[14] + flag[20] + flag[16] == 0xbf (191)
#   auth[9]  = mat[3][3] + mat[2][0] = flag[13] + flag[10]  == 0x92 (146)
#   auth[10] = mat[4][0] + mat[1][2] = flag[20] + flag[12]  == 0x65 (101)
#   auth[11] = mat[0][4] + mat[4][1] = flag[14] + flag[11]  == 0x9d (157)
#   auth[12] = mat[0][3] + mat[0][2] = flag[23] + flag[7]   == 0x9a (154)
#   auth[13] = mat[3][0] + mat[2][0] = flag[15] + flag[10]  == 0x99 (153)
#   auth[14] = mat[1][4] + mat[1][2] = flag[19] + flag[12]  == 0x99 (153)
#   auth[15] = mat[4][3] + mat[2][3] = flag[18] + flag[8]   == 0x94 (148)
#   auth[16] = mat[2][2] + macatt[0][2] = flag[17] + flag[7]   == 0xad (173)
#   auth[17] = mat[1][1] + mat[4][1] = flag[21] + flag[11]  == 0xe4 (228)

# Add the constraints corresponding to the auth string:
s.add(flag[0] + flag[9]   == 0x8b)  # 139
s.add(flag[1] + flag[7]   == 0xce)  # 206
s.add(flag[2] + flag[11]  == 0xb0)  # 176
s.add(flag[3] + flag[6]   == 0x89)  # 137
s.add(flag[4] + flag[12]  == 0x7b)  # 123
s.add(flag[5] + flag[8]   == 0xb0)  # 176
s.add(flag[24] + flag[10] == 0xb0)  # 176
s.add(flag[13] + flag[22] + flag[23] == 0xee)  # 238
s.add(flag[14] + flag[20] + flag[16] == 0xbf)  # 191
s.add(flag[13] + flag[10]  == 0x92)  # 146
s.add(flag[20] + flag[12]  == 0x65)  # 101
s.add(flag[14] + flag[11]  == 0x9d)  # 157
s.add(flag[23] + flag[7]   == 0x9a)  # 154
s.add(flag[15] + flag[10]  == 0x99)  # 153
s.add(flag[19] + flag[12]  == 0x99)  # 153
s.add(flag[18] + flag[8]   == 0x94)  # 148
s.add(flag[17] + flag[7]   == 0xad)  # 173
s.add(flag[21] + flag[11]  == 0xe4)  # 228

'''
s.add(flag[0] == 0x54)
s.add(flag[1] == 0x55)
s.add(flag[2] == 0x43)
s.add(flag[3] == 0x54)
s.add(flag[4] == 0x46)
s.add(flag[5] == 0x7B)
s.add(flag[24] == 0x7D)
'''

if s.check() == sat:
    m = s.model()
    sol = [m[bv].as_long() for bv in flag]
    flag_str = "".join(chr(x) for x in sol)
    print("Flag found:", flag_str)
else:
    print("No solution found.")
