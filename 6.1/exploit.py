import z3

def recover_string_with_z3(ciphertext):
    # A solver instance
    s = z3.Solver()
    
    # We'll treat each character of the unknown plaintext x as a BitVec of 8 bits.
    length = len(ciphertext)
    x_chars = [z3.BitVec(f'x_{i}', 8) for i in range(length)]
    
    # For each position i, impose that x_i XOR 1 = the ciphertext's character code
    for i, c in enumerate(ciphertext):
        s.add(x_chars[i] ^ 1 == ord(c))
    
    # (Optional) constrain x_i to be printable ASCII, for instance:
    #    s.add(x_chars[i] >= 32, x_chars[i] <= 126)
    # if you suspect the plaintext is in normal printable range.

    # Solve
    if s.check() == z3.sat:
        model = s.model()
        # Reconstruct plaintext from the model
        plaintext_chars = [chr(model[x_chars[i]].as_long()) for i in range(length)]
        return "".join(plaintext_chars)
    else:
        return None

if __name__ == "__main__":
    ciphertext = "irbugzv1v^x1t^jo1v^e5^v@2^9i3c@138|"
    plaintext = recover_string_with_z3(ciphertext)
    if plaintext is not None:
        print("Recovered plaintext:", plaintext)
    else:
        print("No solution found.")
