'''
bytes = 41 29 d9 65 a1 f1 e1 c9 19 09 93 13 a1 09 b9 49 b9 89 dd 61 31 69 a1 f1 71 21 9d d5 3d 15 d5 00
'''
import z3
FINAL_BYTES = [
    0x41, 0x29, 0xd9, 0x65, 0xa1, 0xf1, 0xe1, 0xc9,
    0x19, 0x09, 0x93, 0x13, 0xa1, 0x09, 0xb9, 0x49,
    0xb9, 0x89, 0xdd, 0x61, 0x31, 0x69, 0xa1, 0xf1,
    0x71, 0x21, 0x9d, 0xd5, 0x3d, 0x15, 0xd5
]
N = len(FINAL_BYTES)  # 31

def reverse_bits(bv8):
    """Return a 8-bit BitVec with bits reversed."""
    # One way is to do the same operations as the C code:

    # 1) bVar1 = (bv >> 1 & 0x55) | ((bv & 0x55) << 1)
    step1 = ((bv8 >> 1) & 0x55) | ((bv8 & 0x55) << 1)
    # 2) bVar1 = (bVar1 >> 2 & 0x33) | ((bVar1 & 0x33) << 2)
    step2 = ((step1 >> 2) & 0x33) | ((step1 & 0x33) << 2)
    # 3) *local_8 = (bVar1 >> 4) | (bVar1 << 4)
    step3 = ((step2 >> 4) & 0x0f) | ((step2 & 0x0f) << 4)
    return step3

def solve_for_original_string():
    solver = z3.Solver()

    # Our unknown original bytes (not counting final null, which we’ll add).
    x = [z3.BitVec(f"x_{i}", 8) for i in range(N)]

    # 1) Reverse in place => rev[i] = x[N-1 - i]
    # We'll just define an array for the reversed result
    rev = [x[N - 1 - i] for i in range(N)]

    # 2) Bit-reversal => bitrev[i] = reverse_bits(rev[i])
    bitrev = [reverse_bits(rev[i]) for i in range(N)]

    # 3) Bitwise NOT => final[i] = ~bitrev[i]
    # In Z3, ~bitrev[i] is also a 32-bit quantity by default,
    # so we mask to 8 bits with & 0xFF to stay in range.
    final = [(~bitrev[i]) & 0xFF for i in range(N)]

    # 4) Constrain final[i] == FINAL_BYTES[i]
    for i in range(N):
        solver.add(final[i] == FINAL_BYTES[i])

    # Also, the final transformation code stops at 0x00, so presumably
    # the last byte is 0x00 after transformation. According to the
    # provided bytes, the 31st is 0xd5, so the 32nd is 0x00 terminator.
    # If you want to enforce that, you could do:
    #    solver.add(final_32 == 0)
    # but from the snippet provided, it looks like the last of the 31
    # bytes is 0xd5, and then a 0x00 terminator in memory. We'll assume
    # the code naturally writes 0 after the 31 bytes.

    result = solver.check()
    if result == z3.sat:
        model = solver.model()
        # Reconstruct the solution for x_0..x_{N-1}
        solution_bytes = [model[bv].as_long() for bv in x]

        # Optionally interpret as ASCII if it makes sense
        # (only if they’re in a printable range, etc.)
        # For a raw byte array, you can just return them as hex or something.
        solution_string = "".join(chr(b) for b in solution_bytes)
        return solution_bytes, solution_string
    else:
        print("Unsatisfiable or Unknown!")
        return None, None

if __name__ == "__main__":
    sol_bytes, sol_str = solve_for_original_string()
    if sol_bytes is not None:
        print("Found a solution!")
        print("Bytes:", [hex(b) for b in sol_bytes])
        print("As ASCII (if valid):", repr(sol_str))
    else:
        print("No solution found.")

